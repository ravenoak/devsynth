---
description: "Security standards and compliance requirements for all development"
alwaysApply: true
globs: ["**/*.py"]
---

# Security Compliance and Best Practices

## Core Security Principles

### 1. Input Validation and Sanitization
- **All Inputs**: Validate and sanitize all user inputs, API parameters, and file uploads
- **Type Safety**: Use type annotations and validation to prevent type-related vulnerabilities
- **SQL Injection Prevention**: Use parameterized queries and ORM patterns, never string concatenation
- **XSS Prevention**: Sanitize all output to prevent cross-site scripting attacks

### 2. Authentication and Authorization
- **Secure Authentication**: Use established authentication frameworks (OAuth 2.0, JWT, etc.)
- **Authorization Checks**: Implement proper authorization at all access points
- **Session Management**: Secure session handling with appropriate timeouts
- **Password Security**: Use strong password policies and secure hashing (bcrypt, Argon2)

### 3. Data Protection
- **Encryption**: Encrypt sensitive data at rest and in transit
- **Access Control**: Implement least privilege access patterns
- **Audit Trails**: Maintain comprehensive audit logs for all security-relevant actions
- **Data Classification**: Classify data by sensitivity level and apply appropriate controls

## Security Implementation Guidelines

### API Security
```python
# Example secure API implementation
from typing import Optional
from pydantic import BaseModel, Field, validator
import secrets

class UserCreateRequest(BaseModel):
    email: str = Field(..., regex=r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{{2,}}$')
    password: str = Field(..., min_length=12, max_length=128)

    @validator('password')
    def validate_password_strength(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        return v

class SecureAPI:
    def create_user(self, request: UserCreateRequest) -> User:
        # Validate input thoroughly
        # Hash password securely
        # Check for duplicate accounts
        # Log security events
        pass
```

### Database Security
- **Parameterized Queries**: Always use parameterized queries or ORM methods
- **Connection Pooling**: Use connection pooling with appropriate limits
- **Access Control**: Implement database-level access controls
- **Data Encryption**: Encrypt sensitive data at the database level

### Configuration Security
- **Environment Variables**: Store sensitive configuration in environment variables
- **Secret Management**: Use secure secret management systems
- **Configuration Validation**: Validate all configuration values
- **Access Controls**: Protect configuration files and endpoints

## Security Testing

### Testing Requirements
- **Security Test Coverage**: Include security tests for all input validation
- **Penetration Testing**: Regular security testing and vulnerability assessment
- **Dependency Scanning**: Monitor dependencies for known vulnerabilities
- **Static Analysis**: Use security-focused static analysis tools

### Common Vulnerability Testing
```python
# Example security test patterns
def test_sql_injection_prevention():
    # Test that SQL injection attempts are blocked
    malicious_input = "'; DROP TABLE users; --"
    result = process_user_input(malicious_input)
    assert not result.contains_dangerous_sql()

def test_xss_prevention():
    # Test that XSS attempts are sanitized
    malicious_script = "<script>alert('xss')</script>"
    result = sanitize_html(malicious_script)
    assert "<script>" not in result

def test_authentication_bypass():
    # Test that authentication cannot be bypassed
    invalid_token = "fake.jwt.token"
    user = get_user_from_token(invalid_token)
    assert user is None
```

## Compliance Requirements

### Audit and Logging
- **Security Events**: Log all security-relevant events with context
- **Access Logs**: Maintain access logs for compliance
- **Audit Trails**: Implement comprehensive audit trails
- **Log Security**: Protect log files and ensure they cannot be tampered with

### Error Handling
- **Information Disclosure**: Avoid exposing sensitive information in error messages
- **Graceful Degradation**: Implement secure fallback behaviors
- **Error Logging**: Log errors securely without exposing sensitive data
- **User-Friendly Messages**: Provide clear but non-revealing error messages

## Deployment Security

### Infrastructure Security
- **Container Security**: Use secure base images and minimal privileges
- **Network Security**: Implement proper network segmentation and firewall rules
- **Access Management**: Use role-based access control (RBAC)
- **Monitoring**: Implement security monitoring and alerting

### Runtime Security
- **Dependency Updates**: Keep dependencies updated and monitor for vulnerabilities
- **Runtime Protection**: Implement runtime application self-protection (RASP)
- **Resource Limits**: Set appropriate resource limits to prevent DoS attacks
- **Health Checks**: Implement security-focused health checks

## Agent Security Considerations

### AI Agent Security
- **Prompt Injection Prevention**: Protect against prompt injection attacks
- **Output Validation**: Validate all AI-generated content for security compliance
- **Access Control**: Implement proper access controls for AI agent capabilities
- **Audit Integration**: Include AI actions in security audit trails

### Memory Security
- **Data Sanitization**: Sanitize data stored in memory systems
- **Access Control**: Implement access controls for memory system interactions
- **Data Retention**: Implement secure data retention policies
- **Encryption**: Encrypt sensitive data in memory stores

## Security Review Process

### Code Review
- **Security Review**: All changes require security review
- **Threat Modeling**: Conduct threat modeling for new features
- **Security Testing**: Include security tests in all test suites
- **Compliance Check**: Verify compliance with security policies

### Incident Response
- **Detection**: Implement security event detection
- **Response Plan**: Maintain incident response procedures
- **Recovery**: Implement secure recovery procedures
- **Learning**: Learn from security incidents and improve processes

## Related Rules
- **testing-philosophy**: Security testing requirements and practices
- **bdd-workflow**: Security-focused BDD scenarios
- **security-compliance**: Cross-reference to security best practices
- **import_organization**: Secure import patterns and validation
- **error_handling**: Security-focused error handling and logging

This security framework ensures that all development activities maintain the highest security standards and protect the system against common vulnerabilities and threats.
