"""
Decision-making methods for the WSDETeam class.

This module contains methods for decision-making, including idea generation,
option evaluation, and implementation planning.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import uuid4

# Import the base WSDETeam class for type hints
from devsynth.domain.models.wsde_base import WSDETeam
from devsynth.logging_setup import DevSynthLogger

logger = DevSynthLogger(__name__)


def generate_diverse_ideas(
    self: WSDETeam,
    task: Dict[str, Any],
    max_ideas: int = 10,
    diversity_threshold: float = 0.7,
) -> List[Dict[str, Any]]:
    """
    Generate diverse ideas for a task.

    This method generates a set of diverse ideas for solving a task by
    leveraging the expertise of different team members.

    Args:
        self: The WSDETeam instance
        task: The task to generate ideas for
        max_ideas: The maximum number of ideas to generate
        diversity_threshold: The minimum diversity threshold for including an idea

    Returns:
        A list of dictionaries containing the generated ideas
    """
    logger.info(f"Generating diverse ideas for task: {task.get('id', 'unknown')}")

    # Get all agents in the team
    agents = self.agents

    # Generate ideas from each agent
    all_ideas = []
    for agent in agents:
        # Skip agents that can't propose solutions
        if not self.can_propose_solution(agent, task):
            continue

        # Get ideas from the agent
        try:
            agent_ideas = agent.generate_ideas(task, max_ideas=3)

            # Add agent information to each idea
            for idea in agent_ideas:
                idea["agent_id"] = getattr(agent, "id", str(uuid4()))
                idea["agent_name"] = getattr(agent, "name", "unknown")
                idea["timestamp"] = datetime.now().isoformat()

                all_ideas.append(idea)
        except Exception as e:
            logger.error(
                f"Error getting ideas from agent {getattr(agent, 'name', 'unknown')}: {str(e)}"
            )

    # Ensure we have at least some ideas
    if not all_ideas:
        logger.warning("No ideas generated by any agent")
        return []

    # Filter ideas for diversity
    diverse_ideas = [all_ideas[0]]  # Start with the first idea

    for idea in all_ideas[1:]:
        # Check if this idea is sufficiently different from existing diverse ideas
        is_diverse = True

        for existing_idea in diverse_ideas:
            similarity = self._calculate_idea_similarity(idea, existing_idea)
            if similarity > 1 - diversity_threshold:
                is_diverse = False
                break

        if is_diverse:
            diverse_ideas.append(idea)

            # Stop if we have enough diverse ideas
            if len(diverse_ideas) >= max_ideas:
                break

    return diverse_ideas


def _calculate_idea_similarity(
    self: WSDETeam, idea1: Dict[str, Any], idea2: Dict[str, Any]
) -> float:
    """
    Calculate the similarity between two ideas.

    This is a simple implementation that compares the text content of the ideas.
    A more sophisticated implementation would use semantic similarity.

    Args:
        self: The WSDETeam instance
        idea1: The first idea
        idea2: The second idea

    Returns:
        A float between 0 and 1 representing the similarity
    """
    # Extract text content from ideas
    text1 = idea1.get("description", "") + " " + idea1.get("rationale", "")
    text2 = idea2.get("description", "") + " " + idea2.get("rationale", "")

    # Simple word overlap similarity
    words1 = set(text1.lower().split())
    words2 = set(text2.lower().split())

    if not words1 or not words2:
        return 0.0

    intersection = words1.intersection(words2)
    union = words1.union(words2)

    return len(intersection) / len(union)


def create_comparison_matrix(
    self: WSDETeam, ideas: List[Dict[str, Any]], evaluation_criteria: List[str]
) -> Dict[str, Dict[str, float]]:
    """
    Create a comparison matrix for evaluating ideas.

    This method creates a matrix that compares ideas against evaluation criteria.

    Args:
        self: The WSDETeam instance
        ideas: The ideas to compare
        evaluation_criteria: The criteria to evaluate against

    Returns:
        A dictionary containing the comparison matrix
    """
    logger.info("Creating comparison matrix for ideas")

    # Initialize the comparison matrix
    matrix = {}

    for i, idea in enumerate(ideas):
        idea_id = idea.get("id", f"idea_{i+1}")
        matrix[idea_id] = {}

        for criterion in evaluation_criteria:
            # For each idea and criterion, get evaluations from agents
            scores = []

            for agent in self.agents:
                try:
                    # Get the agent's evaluation of this idea for this criterion
                    score = agent.evaluate_idea(idea, criterion)
                    scores.append(score)
                except Exception as e:
                    logger.error(
                        f"Error getting evaluation from agent {getattr(agent, 'name', 'unknown')}: {str(e)}"
                    )

            # Calculate the average score
            if scores:
                matrix[idea_id][criterion] = sum(scores) / len(scores)
            else:
                matrix[idea_id][criterion] = 0.0

    return matrix


def evaluate_options(
    self: WSDETeam,
    ideas: List[Dict[str, Any]],
    comparison_matrix: Dict[str, Dict[str, float]],
    weighting_scheme: Dict[str, float],
) -> List[Dict[str, Any]]:
    """
    Evaluate options based on a comparison matrix and weighting scheme.

    This method calculates weighted scores for each idea and ranks them.

    Args:
        self: The WSDETeam instance
        ideas: The ideas to evaluate
        comparison_matrix: The comparison matrix
        weighting_scheme: The weighting scheme for criteria

    Returns:
        A list of dictionaries containing the evaluated options
    """
    logger.info("Evaluating options")

    # Calculate weighted scores for each idea
    evaluated_options = []

    for i, idea in enumerate(ideas):
        idea_id = idea.get("id", f"idea_{i+1}")

        # Skip ideas that aren't in the comparison matrix
        if idea_id not in comparison_matrix:
            continue

        # Calculate the weighted score
        weighted_score = 0.0
        criterion_scores = {}

        for criterion, weight in weighting_scheme.items():
            # Skip criteria that aren't in the comparison matrix
            if criterion not in comparison_matrix[idea_id]:
                continue

            score = comparison_matrix[idea_id][criterion]
            weighted_criterion_score = score * weight
            weighted_score += weighted_criterion_score

            criterion_scores[criterion] = {
                "raw_score": score,
                "weight": weight,
                "weighted_score": weighted_criterion_score,
            }

        # Create the evaluated option
        evaluated_option = {
            "id": idea_id,
            "idea": idea,
            "criterion_scores": criterion_scores,
            "weighted_score": weighted_score,
        }

        evaluated_options.append(evaluated_option)

    # Sort options by weighted score (descending)
    evaluated_options.sort(key=lambda x: x["weighted_score"], reverse=True)

    return evaluated_options


def analyze_trade_offs(
    self: WSDETeam,
    evaluated_options: List[Dict[str, Any]],
    conflict_detection_threshold: float = 0.7,
    identify_complementary_options: bool = True,
) -> List[Dict[str, Any]]:
    """
    Analyze trade-offs between evaluated options.

    This method identifies conflicts and complementary aspects between options.

    Args:
        self: The WSDETeam instance
        evaluated_options: The evaluated options
        conflict_detection_threshold: The threshold for detecting conflicts
        identify_complementary_options: Whether to identify complementary options

    Returns:
        A list of dictionaries containing the trade-offs
    """
    logger.info("Analyzing trade-offs between options")

    trade_offs = []

    # Get all criteria from the first option (assuming all options have the same criteria)
    if not evaluated_options:
        return trade_offs

    criteria = list(evaluated_options[0].get("criterion_scores", {}).keys())

    # Compare each pair of options
    for i, option1 in enumerate(evaluated_options):
        for j, option2 in enumerate(evaluated_options[i + 1 :], i + 1):
            option1_id = option1.get("id", f"option_{i+1}")
            option2_id = option2.get("id", f"option_{j+1}")

            # Identify criteria where the options have significantly different scores
            conflicts = []
            complementary = []

            for criterion in criteria:
                # Skip criteria that aren't in both options
                if criterion not in option1.get(
                    "criterion_scores", {}
                ) or criterion not in option2.get("criterion_scores", {}):
                    continue

                score1 = option1["criterion_scores"][criterion]["raw_score"]
                score2 = option2["criterion_scores"][criterion]["raw_score"]

                # Check for conflict (one option is significantly better than the other)
                if abs(score1 - score2) > conflict_detection_threshold:
                    better_option = option1_id if score1 > score2 else option2_id
                    worse_option = option2_id if score1 > score2 else option1_id

                    conflicts.append(
                        {
                            "criterion": criterion,
                            "better_option": better_option,
                            "worse_option": worse_option,
                            "score_difference": abs(score1 - score2),
                        }
                    )

                # Check for complementary aspects (both options have high scores)
                elif identify_complementary_options and score1 > 0.7 and score2 > 0.7:
                    complementary.append(
                        {
                            "criterion": criterion,
                            "option1_score": score1,
                            "option2_score": score2,
                        }
                    )

            # Create the trade-off
            if conflicts or complementary:
                trade_off = {
                    "option1_id": option1_id,
                    "option2_id": option2_id,
                    "conflicts": conflicts,
                    "complementary": complementary,
                }

                trade_offs.append(trade_off)

    return trade_offs


def formulate_decision_criteria(
    self: WSDETeam,
    task: Dict[str, Any],
    evaluated_options: List[Dict[str, Any]],
    trade_offs: List[Dict[str, Any]],
    contextualize_with_code: bool = False,
    code_analyzer: Any = None,
) -> Dict[str, float]:
    """
    Formulate decision criteria based on evaluated options and trade-offs.

    This method creates a set of decision criteria for selecting the best option.

    Args:
        self: The WSDETeam instance
        task: The task context
        evaluated_options: The evaluated options
        trade_offs: The trade-offs between options
        contextualize_with_code: Whether to contextualize criteria with code analysis
        code_analyzer: The code analyzer to use

    Returns:
        A dictionary containing the decision criteria
    """
    logger.info("Formulating decision criteria")

    # Extract requirements and constraints from task
    requirements = task.get("requirements", [])
    constraints = task.get("constraints", [])

    # Get all criteria from the first option (assuming all options have the same criteria)
    if not evaluated_options:
        return {}

    criteria = list(evaluated_options[0].get("criterion_scores", {}).keys())

    # Initialize decision criteria with equal weights
    decision_criteria = {criterion: 1.0 / len(criteria) for criterion in criteria}

    # Adjust weights based on requirements
    for req in requirements:
        for criterion in criteria:
            if req.lower() in criterion.lower():
                # Increase weight for criteria related to requirements
                decision_criteria[criterion] *= 1.5

    # Adjust weights based on constraints
    for constraint in constraints:
        for criterion in criteria:
            if constraint.lower() in criterion.lower():
                # Increase weight for criteria related to constraints
                decision_criteria[criterion] *= 1.2

    # Adjust weights based on trade-offs
    for trade_off in trade_offs:
        for conflict in trade_off.get("conflicts", []):
            criterion = conflict.get("criterion")
            if criterion in decision_criteria:
                # Increase weight for criteria with conflicts
                decision_criteria[criterion] *= 1.1

    # Contextualize with code analysis if requested
    if contextualize_with_code and code_analyzer:
        try:
            code_analysis = code_analyzer.analyze_project()

            # Adjust weights based on code analysis
            for criterion in criteria:
                for issue in code_analysis.get("issues", []):
                    if criterion.lower() in issue.get("category", "").lower():
                        # Increase weight for criteria related to code issues
                        decision_criteria[criterion] *= 1.3
        except Exception as e:
            logger.error(
                f"Error contextualizing decision criteria with code analysis: {str(e)}"
            )

    # Normalize weights to sum to 1.0
    total_weight = sum(decision_criteria.values())
    if total_weight > 0:
        for criterion in decision_criteria:
            decision_criteria[criterion] /= total_weight

    return decision_criteria


def select_best_option(
    self: WSDETeam,
    evaluated_options: List[Dict[str, Any]],
    decision_criteria: Dict[str, float],
) -> Dict[str, Any]:
    """
    Select the best option based on decision criteria.

    This method selects the option with the highest score according to the decision criteria.

    Args:
        self: The WSDETeam instance
        evaluated_options: The evaluated options
        decision_criteria: The decision criteria

    Returns:
        A dictionary containing the selected option
    """
    logger.info("Selecting best option")

    if not evaluated_options:
        return {}

    # Calculate scores for each option
    option_scores = []

    for option in evaluated_options:
        score = 0.0

        for criterion, weight in decision_criteria.items():
            if criterion in option.get("criterion_scores", {}):
                score += option["criterion_scores"][criterion]["raw_score"] * weight

        option_scores.append((option, score))

    # Select the option with the highest score
    selected_option, score = max(option_scores, key=lambda x: x[1])

    # Add selection information
    selected_option["selection_score"] = score
    selected_option["selection_criteria"] = decision_criteria

    return selected_option


def elaborate_details(
    self: WSDETeam, selected_option: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """
    Elaborate details for a selected option.

    This method elaborates the details of a selected option, including
    implementation steps, dependencies, and risks.

    Args:
        self: The WSDETeam instance
        selected_option: The selected option

    Returns:
        A list of dictionaries containing the elaborated details
    """
    logger.info("Elaborating details for selected option")

    if not selected_option:
        return []

    # Get the idea from the selected option
    idea = selected_option.get("idea", {})

    # Get all agents in the team
    agents = self.agents

    # Elaborate details from each agent
    details = []

    for agent in agents:
        try:
            # Get details from the agent
            agent_details = agent.elaborate_details(idea)

            # Add agent information to each detail
            for detail in agent_details:
                detail["agent_id"] = getattr(agent, "id", str(uuid4()))
                detail["agent_name"] = getattr(agent, "name", "unknown")
                detail["timestamp"] = datetime.now().isoformat()

                details.append(detail)
        except Exception as e:
            logger.error(
                f"Error getting details from agent {getattr(agent, 'name', 'unknown')}: {str(e)}"
            )

    return details


def create_implementation_plan(
    self: WSDETeam, details: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Create an implementation plan from elaborated details.

    This method creates a structured implementation plan with steps, dependencies,
    and estimated effort.

    Args:
        self: The WSDETeam instance
        details: The elaborated details

    Returns:
        A list of dictionaries containing the implementation plan
    """
    logger.info("Creating implementation plan")

    if not details:
        return []

    # Extract implementation steps from details
    steps = []

    for detail in details:
        # Extract steps from the detail
        detail_steps = detail.get("steps", [])

        for step in detail_steps:
            # Add metadata to the step
            step["source_detail_id"] = detail.get("id", str(uuid4()))
            step["source_agent_id"] = detail.get("agent_id", "unknown")
            step["source_agent_name"] = detail.get("agent_name", "unknown")

            steps.append(step)

    # Sort steps by dependencies
    sorted_steps = self._topological_sort_steps(steps)

    # Assign step numbers
    for i, step in enumerate(sorted_steps):
        step["step_number"] = i + 1

    return sorted_steps


def _topological_sort_steps(
    self: WSDETeam, steps: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Sort steps topologically based on dependencies.

    This method sorts steps such that dependencies come before dependent steps.

    Args:
        self: The WSDETeam instance
        steps: The steps to sort

    Returns:
        A list of dictionaries containing the sorted steps
    """
    # Create a mapping from step ID to step
    step_map = {step.get("id", str(uuid4())): step for step in steps}

    # Create a graph of dependencies
    graph = {step_id: [] for step_id in step_map}

    for step_id, step in step_map.items():
        dependencies = step.get("dependencies", [])

        for dep_id in dependencies:
            if dep_id in graph:
                graph[dep_id].append(step_id)

    # Perform topological sort
    visited = set()
    temp_visited = set()
    order = []

    def visit(node):
        if node in temp_visited:
            # Cycle detected
            return

        if node in visited:
            return

        temp_visited.add(node)

        for neighbor in graph.get(node, []):
            visit(neighbor)

        temp_visited.remove(node)
        visited.add(node)
        order.append(node)

    for node in graph:
        if node not in visited:
            visit(node)

    # Reverse the order to get dependencies first
    order.reverse()

    # Convert back to steps
    sorted_steps = [step_map[step_id] for step_id in order if step_id in step_map]

    return sorted_steps


def optimize_implementation(
    self: WSDETeam,
    plan: List[Dict[str, Any]],
    optimization_targets: List[str],
    code_analyzer: Any = None,
) -> List[Dict[str, Any]]:
    """
    Optimize an implementation plan.

    This method optimizes an implementation plan based on specified targets,
    such as performance, maintainability, or security.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        optimization_targets: The optimization targets
        code_analyzer: The code analyzer to use

    Returns:
        A list of dictionaries containing the optimized plan
    """
    logger.info("Optimizing implementation plan")

    if not plan:
        return []

    # Create a copy of the plan to optimize
    optimized_plan = [step.copy() for step in plan]

    # Apply optimizations based on targets
    for target in optimization_targets:
        if target.lower() == "performance":
            optimized_plan = self._optimize_for_performance(
                optimized_plan, code_analyzer
            )
        elif target.lower() == "maintainability":
            optimized_plan = self._optimize_for_maintainability(
                optimized_plan, code_analyzer
            )
        elif target.lower() == "security":
            optimized_plan = self._optimize_for_security(optimized_plan, code_analyzer)

    return optimized_plan


def _optimize_for_performance(
    self: WSDETeam, plan: List[Dict[str, Any]], code_analyzer: Any = None
) -> List[Dict[str, Any]]:
    """
    Optimize an implementation plan for performance.

    This method optimizes an implementation plan to improve performance.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        code_analyzer: The code analyzer to use

    Returns:
        A list of dictionaries containing the optimized plan
    """
    # Create a copy of the plan
    optimized_plan = [step.copy() for step in plan]

    # Add performance optimization notes to relevant steps
    for step in optimized_plan:
        description = step.get("description", "").lower()

        if "database" in description or "query" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Consider adding indexes to improve query performance",
                "Use query optimization techniques like eager loading or query caching",
            ]

        if "loop" in description or "iteration" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Optimize loops to minimize iterations",
                "Consider using more efficient data structures",
            ]

        if "algorithm" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Analyze algorithm complexity and optimize if possible",
                "Consider using more efficient algorithms",
            ]

    return optimized_plan


def _optimize_for_maintainability(
    self: WSDETeam, plan: List[Dict[str, Any]], code_analyzer: Any = None
) -> List[Dict[str, Any]]:
    """
    Optimize an implementation plan for maintainability.

    This method optimizes an implementation plan to improve maintainability.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        code_analyzer: The code analyzer to use

    Returns:
        A list of dictionaries containing the optimized plan
    """
    # Create a copy of the plan
    optimized_plan = [step.copy() for step in plan]

    # Add maintainability optimization notes to relevant steps
    for step in optimized_plan:
        description = step.get("description", "").lower()

        if "class" in description or "function" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Follow SOLID principles for better maintainability",
                "Keep classes and functions small and focused on a single responsibility",
            ]

        if "test" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Write comprehensive tests to ensure code correctness",
                "Use test-driven development (TDD) approach",
            ]

        if "documentation" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Write clear and comprehensive documentation",
                "Include examples and use cases in documentation",
            ]

    return optimized_plan


def _optimize_for_security(
    self: WSDETeam, plan: List[Dict[str, Any]], code_analyzer: Any = None
) -> List[Dict[str, Any]]:
    """
    Optimize an implementation plan for security.

    This method optimizes an implementation plan to improve security.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        code_analyzer: The code analyzer to use

    Returns:
        A list of dictionaries containing the optimized plan
    """
    # Create a copy of the plan
    optimized_plan = [step.copy() for step in plan]

    # Add security optimization notes to relevant steps
    for step in optimized_plan:
        description = step.get("description", "").lower()

        if "authentication" in description or "login" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Implement secure authentication mechanisms",
                "Use multi-factor authentication where appropriate",
                "Store passwords securely using strong hashing algorithms",
            ]

        if "data" in description or "database" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Encrypt sensitive data at rest and in transit",
                "Implement proper access controls for data",
                "Sanitize user inputs to prevent SQL injection",
            ]

        if "api" in description or "endpoint" in description:
            step["optimization_notes"] = step.get("optimization_notes", []) + [
                "Implement proper API authentication and authorization",
                "Rate limit API requests to prevent abuse",
                "Validate and sanitize all API inputs",
            ]

    return optimized_plan


def perform_quality_assurance(
    self: WSDETeam,
    plan: List[Dict[str, Any]],
    check_categories: List[str],
    code_analyzer: Any = None,
) -> Dict[str, Any]:
    """
    Perform quality assurance on an implementation plan.

    This method performs quality assurance checks on an implementation plan,
    identifying potential issues and suggesting improvements.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        check_categories: The categories of checks to perform
        code_analyzer: The code analyzer to use

    Returns:
        A dictionary containing the quality assurance results
    """
    logger.info("Performing quality assurance on implementation plan")

    if not plan:
        return {}

    # Initialize quality assurance results
    qa_results = {
        "id": str(uuid4()),
        "timestamp": datetime.now().isoformat(),
        "checks": [],
        "issues": [],
        "suggestions": [],
    }

    # Perform checks based on categories
    for category in check_categories:
        if category.lower() == "completeness":
            self._check_completeness(plan, qa_results)
        elif category.lower() == "consistency":
            self._check_consistency(plan, qa_results)
        elif category.lower() == "testability":
            self._check_testability(plan, qa_results)
        elif category.lower() == "security":
            self._check_security(plan, qa_results)

    # Add overall assessment
    issue_count = len(qa_results["issues"])
    suggestion_count = len(qa_results["suggestions"])

    if issue_count == 0:
        qa_results["overall_assessment"] = "Excellent"
    elif issue_count <= 2:
        qa_results["overall_assessment"] = "Good"
    elif issue_count <= 5:
        qa_results["overall_assessment"] = "Fair"
    else:
        qa_results["overall_assessment"] = "Poor"

    qa_results["summary"] = (
        f"Found {issue_count} issues and {suggestion_count} suggestions for improvement."
    )

    return qa_results


def _check_completeness(
    self: WSDETeam, plan: List[Dict[str, Any]], qa_results: Dict[str, Any]
) -> None:
    """
    Check the completeness of an implementation plan.

    This method checks if the implementation plan is complete, with all
    necessary steps and dependencies.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        qa_results: The quality assurance results to update
    """
    # Add the check to the results
    qa_results["checks"].append(
        {
            "category": "completeness",
            "description": "Check if the implementation plan is complete",
        }
    )

    # Check if the plan has steps
    if not plan:
        qa_results["issues"].append(
            {
                "category": "completeness",
                "severity": "high",
                "description": "The implementation plan has no steps",
            }
        )
        return

    # Check if all steps have descriptions
    for i, step in enumerate(plan):
        if not step.get("description"):
            qa_results["issues"].append(
                {
                    "category": "completeness",
                    "severity": "medium",
                    "description": f"Step {i+1} has no description",
                }
            )

    # Check if all dependencies exist
    step_ids = {step.get("id") for step in plan if step.get("id")}

    for i, step in enumerate(plan):
        dependencies = step.get("dependencies", [])

        for dep_id in dependencies:
            if dep_id not in step_ids:
                qa_results["issues"].append(
                    {
                        "category": "completeness",
                        "severity": "high",
                        "description": f"Step {i+1} depends on non-existent step with ID {dep_id}",
                    }
                )

    # Check if the plan has a clear starting point (steps with no dependencies)
    start_steps = [step for step in plan if not step.get("dependencies")]

    if not start_steps:
        qa_results["issues"].append(
            {
                "category": "completeness",
                "severity": "medium",
                "description": "The implementation plan has no clear starting point (all steps have dependencies)",
            }
        )

    # Check if the plan has a clear ending point (steps that no other steps depend on)
    end_steps = []

    for step in plan:
        step_id = step.get("id")
        if step_id:
            is_dependency = False

            for other_step in plan:
                if step_id in other_step.get("dependencies", []):
                    is_dependency = True
                    break

            if not is_dependency:
                end_steps.append(step)

    if not end_steps:
        qa_results["issues"].append(
            {
                "category": "completeness",
                "severity": "medium",
                "description": "The implementation plan has no clear ending point (all steps are dependencies for other steps)",
            }
        )

    # Suggest adding more details if steps are too brief
    for i, step in enumerate(plan):
        description = step.get("description", "")

        if len(description.split()) < 5:
            qa_results["suggestions"].append(
                {
                    "category": "completeness",
                    "description": f"Consider adding more details to step {i+1}",
                }
            )


def _check_consistency(
    self: WSDETeam, plan: List[Dict[str, Any]], qa_results: Dict[str, Any]
) -> None:
    """
    Check the consistency of an implementation plan.

    This method checks if the implementation plan is consistent, with no
    contradictions or redundancies.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        qa_results: The quality assurance results to update
    """
    # Add the check to the results
    qa_results["checks"].append(
        {
            "category": "consistency",
            "description": "Check if the implementation plan is consistent",
        }
    )

    # Check if the plan has steps
    if not plan:
        return

    # Check for duplicate steps
    descriptions = {}

    for i, step in enumerate(plan):
        description = step.get("description", "").lower()

        if description in descriptions:
            qa_results["issues"].append(
                {
                    "category": "consistency",
                    "severity": "medium",
                    "description": f"Steps {descriptions[description]+1} and {i+1} have similar descriptions",
                }
            )
        else:
            descriptions[description] = i

    # Check for circular dependencies
    try:
        self._topological_sort_steps(plan)
    except Exception:
        qa_results["issues"].append(
            {
                "category": "consistency",
                "severity": "high",
                "description": "The implementation plan has circular dependencies",
            }
        )

    # Check for inconsistent effort estimates
    effort_units = set()

    for step in plan:
        effort = step.get("effort")

        if effort:
            if isinstance(effort, str):
                unit = effort.split()[-1] if len(effort.split()) > 1 else ""
                effort_units.add(unit)

    if len(effort_units) > 1:
        qa_results["issues"].append(
            {
                "category": "consistency",
                "severity": "low",
                "description": f"The implementation plan uses inconsistent effort units: {', '.join(effort_units)}",
            }
        )

    # Suggest standardizing terminology
    terms = {}

    for i, step in enumerate(plan):
        description = step.get("description", "").lower()

        for term in ["implement", "create", "develop", "build"]:
            if term in description:
                terms[term] = terms.get(term, 0) + 1

    if len(terms) > 1:
        most_common_term = max(terms.items(), key=lambda x: x[1])[0]

        qa_results["suggestions"].append(
            {
                "category": "consistency",
                "description": f"Consider standardizing terminology by using '{most_common_term}' consistently",
            }
        )


def _check_testability(
    self: WSDETeam, plan: List[Dict[str, Any]], qa_results: Dict[str, Any]
) -> None:
    """
    Check the testability of an implementation plan.

    This method checks if the implementation plan includes appropriate
    testing steps and considerations.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        qa_results: The quality assurance results to update
    """
    # Add the check to the results
    qa_results["checks"].append(
        {
            "category": "testability",
            "description": "Check if the implementation plan includes appropriate testing",
        }
    )

    # Check if the plan has steps
    if not plan:
        return

    # Check if the plan includes testing steps
    test_steps = [
        step for step in plan if "test" in step.get("description", "").lower()
    ]

    if not test_steps:
        qa_results["issues"].append(
            {
                "category": "testability",
                "severity": "high",
                "description": "The implementation plan does not include any testing steps",
            }
        )

        qa_results["suggestions"].append(
            {
                "category": "testability",
                "description": "Add steps for unit testing, integration testing, and end-to-end testing",
            }
        )

    # Check if there are tests for each implementation step
    implementation_steps = [
        step
        for step in plan
        if any(
            term in step.get("description", "").lower()
            for term in ["implement", "create", "develop", "build"]
        )
    ]

    if implementation_steps and len(test_steps) < len(implementation_steps) * 0.5:
        qa_results["issues"].append(
            {
                "category": "testability",
                "severity": "medium",
                "description": f"The implementation plan has {len(test_steps)} test steps for {len(implementation_steps)} implementation steps",
            }
        )

        qa_results["suggestions"].append(
            {
                "category": "testability",
                "description": "Add more test steps to ensure adequate test coverage",
            }
        )

    # Check if the plan includes different types of testing
    test_types = {"unit": False, "integration": False, "end-to-end": False}

    for step in test_steps:
        description = step.get("description", "").lower()

        if "unit test" in description:
            test_types["unit"] = True

        if "integration test" in description:
            test_types["integration"] = True

        if "end-to-end test" in description or "e2e test" in description:
            test_types["end-to-end"] = True

    missing_test_types = [
        test_type for test_type, included in test_types.items() if not included
    ]

    if missing_test_types:
        qa_results["issues"].append(
            {
                "category": "testability",
                "severity": "medium",
                "description": f"The implementation plan is missing {', '.join(missing_test_types)} tests",
            }
        )

        qa_results["suggestions"].append(
            {
                "category": "testability",
                "description": f"Add {', '.join(missing_test_types)} tests to ensure comprehensive testing",
            }
        )


def _check_security(
    self: WSDETeam, plan: List[Dict[str, Any]], qa_results: Dict[str, Any]
) -> None:
    """
    Check the security considerations in an implementation plan.

    This method checks if the implementation plan includes appropriate
    security considerations and steps.

    Args:
        self: The WSDETeam instance
        plan: The implementation plan
        qa_results: The quality assurance results to update
    """
    # Add the check to the results
    qa_results["checks"].append(
        {
            "category": "security",
            "description": "Check if the implementation plan includes appropriate security considerations",
        }
    )

    # Check if the plan has steps
    if not plan:
        return

    # Check if the plan includes security steps
    security_steps = [
        step for step in plan if "security" in step.get("description", "").lower()
    ]

    if not security_steps:
        qa_results["issues"].append(
            {
                "category": "security",
                "severity": "high",
                "description": "The implementation plan does not include any security steps",
            }
        )

        qa_results["suggestions"].append(
            {
                "category": "security",
                "description": "Add steps for security considerations, such as input validation, authentication, and authorization",
            }
        )

    # Check for specific security considerations
    security_considerations = {
        "input validation": False,
        "authentication": False,
        "authorization": False,
        "encryption": False,
        "secure communication": False,
    }

    for step in plan:
        description = step.get("description", "").lower()

        for consideration in security_considerations:
            if consideration in description:
                security_considerations[consideration] = True

    missing_considerations = [
        consideration
        for consideration, included in security_considerations.items()
        if not included
    ]

    if missing_considerations:
        qa_results["issues"].append(
            {
                "category": "security",
                "severity": "medium",
                "description": f"The implementation plan is missing security considerations for {', '.join(missing_considerations)}",
            }
        )

        qa_results["suggestions"].append(
            {
                "category": "security",
                "description": f"Add steps to address {', '.join(missing_considerations)}",
            }
        )

    # Check if security testing is included
    security_testing = False

    for step in plan:
        description = step.get("description", "").lower()

        if (
            "security test" in description
            or "penetration test" in description
            or "vulnerability scan" in description
        ):
            security_testing = True
            break

    if not security_testing:
        qa_results["issues"].append(
            {
                "category": "security",
                "severity": "medium",
                "description": "The implementation plan does not include security testing",
            }
        )

        qa_results["suggestions"].append(
            {
                "category": "security",
                "description": "Add steps for security testing, such as vulnerability scanning or penetration testing",
            }
        )
